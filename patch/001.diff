# Patch 001
# Summary:
#   - Sweep 기능 추가
#   - planes_per_group, cache_depth_per_plane: 리스트 스윕 지원
#   - com0_us_per_vec, com1_us_per_vec: linspace 스윕 지원 (--com0-lin, --com1-lin)
#
# Files:
#   - simulator.py
#
# New/Changed Args:
#   --planes-per-group: 단일 값 또는 리스트 (예: 1,2,4,8)
#   --cache-depth-per-plane: 단일 값 또는 리스트 (예: 0,1)
#   --com0-us-per-vec: 단일 값 (linspace 미사용 시)
#   --com1-us-per-vec: 단일 값 (linspace 미사용 시)
#   --com0-lin: linspace "start:end:num" 또는 "start,end,num"
#   --com1-lin: linspace "start:end:num" 또는 "start,end,num"
#
# Usage Example:
#   python simulator.py run \
#     --mode INT,EXT \
#     --planes-per-group 1,2,4,8 \
#     --cache-depth-per-plane 0,1 \
#     --com0-lin 10:100:4 \
#     --com1-lin 0:50:3 \
#     --total-planes 16 --n-queries 64 --query-total-vecs 64 \
#     --vector-dist-mode spread --access-mode seq \
#     --page-bytes 4096 --vector-bytes 1024 \
#     --tR-us 50 --tR-hit-us 0 \
#     --io-gbps 8 --io-units-total 1 \
#     --out-bytes-per-vector 1024 \
#     --tCA-us 0 --ca-issue-width 1 --t-cmd-gap-us 0 \
#     --csv sweep_001.csv
--- a/simulator.py
+++ b/simulator.py
@@
 def union_duration(iv: List[Tuple[float,float]]) -> float:
     if not iv: return 0.0
     ivs = sorted(iv)
     cur_s, cur_e = ivs[0]
     total = 0.0
     for s,e in ivs[1:]:
         if s > cur_e:
             total += (cur_e - cur_s)
             cur_s, cur_e = s,e
         else:
             if e > cur_e: cur_e = e
     total += (cur_e - cur_s)
     return total
+
+def linspace_inclusive(a: float, b: float, n: int) -> List[float]:
+    """Generate n points from a to b inclusive (n>=1)."""
+    if n <= 1:
+        return [float(a)]
+    step = (float(b) - float(a)) / (n - 1)
+    return [float(a) + i*step for i in range(n)]
@@ def main():
-    ap = argparse.ArgumentParser()
+    ap = argparse.ArgumentParser()
     ap.add_argument("cmd", choices=["run"])
-    ap.add_argument("--mode", default="INT", help="INT,EXT 또는 'INT,EXT'")
-    ap.add_argument("--total-planes", type=int, default=16)
-    ap.add_argument("--planes-per-group", type=int, default=4)
+    ap.add_argument("--mode", default="INT", help="INT,EXT 또는 'INT,EXT'")
+    ap.add_argument("--total-planes", type=int, default=16)
+    # sweep: list 지원
+    ap.add_argument("--planes-per-group", default="4",
+                    help="예: '1,2,4,8' 또는 단일 '4'")
@@ def main():
-    ap.add_argument("--com0-us-per-vec", type=float, default=50.0)
-    ap.add_argument("--com1-us-per-vec", type=float, default=0.0)
-    ap.add_argument("--com-parallel", default="off", choices=["off","on"])
+    # com0/com1: 단일 값 또는 linspace 스윕 지원
+    ap.add_argument("--com0-us-per-vec", default="50.0",
+                    help="단일 값 또는 linspace 미사용 시")
+    ap.add_argument("--com1-us-per-vec", default="0.0",
+                    help="단일 값 또는 linspace 미사용 시")
+    ap.add_argument("--com0-lin", default=None,
+                    help="linspace: 'start:end:num' 또는 'start,end,num'")
+    ap.add_argument("--com1-lin", default=None,
+                    help="linspace: 'start:end:num' 또는 'start,end,num'")
+    ap.add_argument("--com-parallel", default="off", choices=["off","on"])
@@ def main():
-    ap.add_argument("--cache-depth-per-plane", type=int, default=0)
+    # cache depth: list 지원
+    ap.add_argument("--cache-depth-per-plane", default="0",
+                    help="예: '0,1' 또는 단일 '0'")
@@ def main():
-        rows = []
-        # sweep over multi-values
-        for mode in mode_list:
-            for vdm in vdm_list:
-                for am in am_list:
-                    p = Params({
-                        "mode": [mode],
-                        "total_planes": args.total_planes,
-                        "planes_per_group": args.planes_per_group,
-                        "n_queries": args.n_queries,
-                        "query_total_vecs": args.query_total_vecs,
-                        "page_bytes": args.page_bytes,
-                        "vector_bytes": args.vector_bytes,
-                        "tR_us": args.tR_us,
-                        "tR_hit_us": args.tR_hit_us,
-                        "com0_us_per_vec": args.com0_us_per_vec,
-                        "com1_us_per_vec": args.com1_us_per_vec,
-                        "com_parallel": args.com_parallel,
-                        "io_gbps": args.io_gbps,
-                        "io_units_total": args.io_units_total,
-                        "out_bytes_per_vector": args.out_bytes_per_vector,
-                        "vector_dist_mode": vdm,
-                        "access_mode": am,
-                        "tCA_us": args.tCA_us,
-                        "ca_issue_width": args.ca_issue_width,
-                        "t_cmd_gap_us": args.t_cmd_gap_us,
-                        "cache_depth_per_plane": args.cache_depth_per_plane,
-                        "ca_can_overlap_io": args.ca_can_overlap_io,
-                    })
-                    out = run_one(p)
-                    if isinstance(out, list):
-                        rows.extend(out)
-                    else:
-                        rows.append(out)
+        # --- sweep lists ---
+        pp_list = parse_multi(args.planes_per_group, int)
+        cd_list = parse_multi(args.cache_depth_per_plane, int)
+        if args.com0_lin:
+            s = args.com0_lin.replace(",", ":")
+            a,b,n = s.split(":")
+            com0_list = [float(x) for x in linspace_inclusive(float(a), float(b), int(n))]
+        else:
+            com0_list = parse_multi(args.com0_us_per_vec, float)
+        if args.com1_lin:
+            s = args.com1_lin.replace(",", ":")
+            a,b,n = s.split(":")
+            com1_list = [float(x) for x in linspace_inclusive(float(a), float(b), int(n))]
+        else:
+            com1_list = parse_multi(args.com1_us_per_vec, float)
+
+        rows = []
+        for mode in mode_list:
+            for vdm in vdm_list:
+                for am in am_list:
+                    for pp in pp_list:
+                        for cd in cd_list:
+                            for c0 in com0_list:
+                                for c1 in com1_list:
+                                    p = Params({
+                                        "mode": [mode],
+                                        "total_planes": args.total_planes,
+                                        "planes_per_group": pp,
+                                        "n_queries": args.n_queries,
+                                        "query_total_vecs": args.query_total_vecs,
+                                        "page_bytes": args.page_bytes,
+                                        "vector_bytes": args.vector_bytes,
+                                        "tR_us": args.tR_us,
+                                        "tR_hit_us": args.tR_hit_us,
+                                        "com0_us_per_vec": c0,
+                                        "com1_us_per_vec": c1,
+                                        "com_parallel": args.com_parallel,
+                                        "io_gbps": args.io_gbps,
+                                        "io_units_total": args.io_units_total,
+                                        "out_bytes_per_vector": args.out_bytes_per_vector,
+                                        "vector_dist_mode": vdm,
+                                        "access_mode": am,
+                                        "tCA_us": args.tCA_us,
+                                        "ca_issue_width": args.ca_issue_width,
+                                        "t_cmd_gap_us": args.t_cmd_gap_us,
+                                        "cache_depth_per_plane": cd,
+                                        "ca_can_overlap_io": args.ca_can_overlap_io,
+                                    })
+                                    out = run_one(p)
+                                    if isinstance(out, list):
+                                        rows.extend(out)
+                                    else:
+                                        rows.append(out)
