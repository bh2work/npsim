diff --git a/simulator.py b/simulator.py
index 1111111..2222222 100644
--- a/simulator.py
+++ b/simulator.py
@@ -1,7 +1,7 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 """
-Base + Patch 001 (baked)
+Base + Patch 001 (baked) + Patch 002
 Summary:
   - Sweep 기능 내장
   - planes_per_group, cache_depth_per_plane: 리스트 스윕 지원
@@ -36,6 +36,22 @@ class Result:
         self.array_throttled_by_cap_frac = 0.0
         self.plane_max_outstanding = 0
 
+# ----- Patch 002: CSV column policy (compact mode by default) -----
+PARAM_KEYS = [
+    "mode","total_planes","planes_per_group","n_queries","query_total_vecs",
+    "vector_dist_mode","access_mode","page_bytes","vector_bytes","tR_us","tR_hit_us",
+    "com0_us_per_vec","com1_us_per_vec","com_parallel","io_gbps","io_units_total",
+    "out_bytes_per_vector","tCA_us","ca_issue_width","t_cmd_gap_us",
+    "cache_depth_per_plane","ca_can_overlap_io",
+]
+RESULT_KEYS_COMPACT = [
+    "avg_query_latency_us","ext_avg_query_latency_us","rel_int_over_ext_latency",
+    "throughput_GBps_io","util_ARRAY","util_COM","util_IO",
+    "array_avg_concurrency","array_util_avg_per_plane_pct","com_util_avg_per_unit_pct",
+]
+# ------------------------------------------------------------------
+
 # ---------------------- Helpers ----------------------
 def _VPP(p: Params) -> int:
     return max(1, p.page_bytes // p.vector_bytes)
@@ -211,6 +227,22 @@ def res_to_row(p: Params, mode: str, r: Result, ext_baseline: Optional[Result]):
     }
     return row
 
+def _build_sweep_keyset(mode_list, vdm_list, am_list, pp_list, cd_list, com0_list, com1_list):
+    sweep = set()
+    if len(mode_list) > 1: sweep.add("mode")
+    if len(vdm_list)  > 1: sweep.add("vector_dist_mode")
+    if len(am_list)   > 1: sweep.add("access_mode")
+    if len(pp_list)   > 1: sweep.add("planes_per_group")
+    if len(cd_list)   > 1: sweep.add("cache_depth_per_plane")
+    if len(com0_list) > 1: sweep.add("com0_us_per_vec")
+    if len(com1_list) > 1: sweep.add("com1_us_per_vec")
+    return sweep
+
+def _compact_row(row: dict, sweep_keys: set) -> dict:
+    keep = set(sweep_keys) | set(RESULT_KEYS_COMPACT)
+    return {k: v for k, v in row.items() if (k in keep)}
+
 # ---------------------- CLI ----------------------
 def parse_multi(s: str, caster):
     xs = [w.strip() for w in s.split(",") if w.strip()!=""]
@@ -254,6 +286,7 @@ def main():
     ap.add_argument("--cache-depth-per-plane", default="0",
                     help="예: '0,1' 또는 단일 '0'")
     ap.add_argument("--ca-can-overlap-io", default="on", choices=["on","off"])
+    ap.add_argument("--csv-full", action="store_true", help="write all columns")
     ap.add_argument("--csv", default="results.csv")
     args = ap.parse_args()
 
@@ -282,6 +315,8 @@ def main():
         else:
             com1_list = parse_multi(args.com1_us_per_vec, float)
 
+        sweep_keys = _build_sweep_keyset(mode_list, vdm_list, am_list, pp_list, cd_list, com0_list, com1_list)
+
         rows = []
         for mode in mode_list:
             for vdm in vdm_list:
@@ -313,13 +348,22 @@ def main():
                                         "cache_depth_per_plane": cd,
                                         "ca_can_overlap_io": args.ca_can_overlap_io,
                                     })
-                                    out = run_one(p)
-                                    if isinstance(out, list):
-                                        rows.extend(out)
-                                    else:
-                                        rows.append(out)
+                                    out = run_one(p)
+                                    if args.csv_full:
+                                        if isinstance(out, list):
+                                            rows.extend(out)
+                                        else:
+                                            rows.append(out)
+                                    else:
+                                        if isinstance(out, list):
+                                            rows.extend([_compact_row(r, sweep_keys) for r in out])
+                                        else:
+                                            rows.append(_compact_row(out, sweep_keys))
 
         cols = list(rows[0].keys()) if rows else []
         with open(args.csv, "w", newline="") as f:
             w = csv.DictWriter(f, fieldnames=cols)
             w.writeheader()
             for r in rows:
                 w.writerow(r)
         print(f"Wrote {len(rows)} rows → {args.csv}")
